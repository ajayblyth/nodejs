-------------------------------------------------------------
NODE.JS: INTRODUCTION & ORIGINS
-------------------------------------------------------------

1. What is Node.js?
-------------------
- Node.js = Environment to run JavaScript outside of the browser.
- Created in 2009 by Ryan Dahl.
- Built on top of Chromeâ€™s V8 JavaScript engine.
- Purpose: Run JS on the server, not just in browsers.

2. V8 JavaScript Engine
-----------------------
- Every browser has an engine to compile JS â†’ machine code.
- Chrome uses **V8 engine** (fast, optimized).
- Node.js takes V8 out of Chrome and runs it standalone.
- This allows JavaScript to run directly on the operating system.

3. Why Node.js?
---------------
3.1 Community:
    - Large open-source community.
    - Many libraries/packages available via npm.
    - Saves development time.

3.2 Full-Stack Development:
    - Frontend + Backend both in JavaScript.
    - Easier for developers to build full apps with one language.
    - Eliminates "language switching" between client and server.

-------------------------------------------------------------
NODE.JS: REQUIREMENTS, DIFFERENCES & INSTALLATION
-------------------------------------------------------------

1. Course_Udemy Requirements
----------------------
- Prerequisites:
  * Basic HTML
  * Simple CSS
  * General understanding of JavaScript:
      - ES6 features
      - Callbacks
      - Promises
      - async/await
- Instructor will not cover deep JS basics (focus = Node.js).
- If needed: Brush up using "Coding Addict" YouTube channel,
  especially the "JS Nuggets" playlist (covers ES6 & async JS).

2. Browser JS vs Node.js
------------------------
2.1 What Node.js does NOT have:
    - No browser APIs (no DOM, no window object, no fetch,
      no geolocation, etc.)
    - Node apps = pure logic, not interactive UIs.
    - You wonâ€™t use `document.querySelector` in Node.

2.2 What Node.js DOES provide:
    - File system access
    - Operating system info
    - Responding to network requests
    - Modules system (CommonJS by default)

2.3 Versions:
    - Node apps depend only on the Node version used.
    - Different from browsers (where features depend on userâ€™s browser).
    - You can keep running your app on the same Node version
      without worrying about browser compatibility.

2.4 Modules in Node:
    - Available by default.
    - Node uses **CommonJS module system**.
    - Concept is similar to ES6 modules, but syntax differs.
      Example:
        const fs = require('fs');   // CommonJS
        import fs from 'fs';        // ES6 (browser style)

3. Installing Node.js
---------------------
3.1 Steps:
    - Visit: https://nodejs.org
    - Choose **LTS version** (Long Term Support).
    - Download & run installer.
    - Click through prompts (Yes/Agree/Install).
    - Enter system password if required.
    - After install, remove installer file if you want.

3.2 Verify Installation:
    - Open terminal.
    - Run: node --version
    - Expected: shows version number (e.g., v14.x, v18.x, v20.x).

3.3 Troubleshooting:
    - If version does not appear, installation failed.
    - Instructor cannot debug your local setup.
    - Use Google/search engines for specific errors.

3.4 LTS vs Current:
    - Node.js offers two releases:
        a) **LTS** = Long Term Support (recommended for production).
        b) Current = Latest features, less stable for production.
    - Always prefer LTS for stability.
    - If your version is newer than instructorâ€™s, no issue.
    - Course_Udemy content will work fine with future LTS versions.


================================================================================
INDEX
================================================================================
1. Creating a Node Project
2. Globals in Node.js
3. Modules in Node.js
4. Splitting Code into Modules
5. Node Modules: Basic Setup & Execution
6. Using Built-in Modules
7. OS Module
8. Path Module
9. File System (FS) Module
10. Synchronous vs Asynchronous
11. HTTP Module: Basic Server Setup
12. Node Package Manager (NPM)
13. Key Takeaways
================================================================================

1. CREATING A NODE PROJECT
--------------------------------------------------------------------------------
- Create folder "tutorial" â†’ open with Code.
- Create file "app.js". Node runs JS outside browser.

Example:
    const amount = 12;

    if (amount < 10) {
        console.log("small number");
    } else {
        console.log("large number");
    }

    console.log(`hey, it's my first node app`);

Run in terminal:
    > node app.js

- From any directory use full path:
    > node /Users/username/Desktop/tutorial/app.js

- In VS Code integrated terminal (Ctrl + ~):
    > node app.js

================================================================================
2. GLOBALS IN NODE.JS
--------------------------------------------------------------------------------
- Meaning:
  "Globals" are identifiers Node provides automatically.
  You can use them anywhere without importing.
  They belong to Node's global object (`global` / `globalThis`).

- Important Note:
  Node wraps each file in a function.
  -> Top-level variables (let/const/var) are NOT global.
  -> True global only if attached to `global.myVar`.

- Common Globals:
  __dirname     : Directory path of current module (CommonJS only)
  __filename    : File path of current module (CommonJS only)
  require       : Import CommonJS modules
  module/exports: Info & export object for current module
  process       : Runtime/env info (env vars, args, exit, etc.)
  console       : Global logging methods
  setTimeout    : Run function after delay (clearTimeout to stop)
  setInterval   : Run repeatedly after interval (clearInterval to stop)
  global        : Node's global object
  globalThis    : Standard global object (works in Node & browsers)

- Example:
  6. Example using All Common Globals
  --------------------------------------------------------------------------------
  const path = require("path");   // <-- using require (CommonJS)

  // __dirname & __filename

  console.log("Directory:", __dirname);
  console.log("File:", __filename);

  // module / exports
  console.log("Module Info:", module.id);

  // process (env + args)
  console.log("Node Version:", process.version);
  console.log("Arguments:", process.argv);

  // console
  console.log("Logging something with console.log");

  // setTimeout + setInterval
  const timer = setInterval(() => {
      console.log("Interval running...");
  }, 1000);

  setTimeout(() => {
      console.log("Stopping interval after 3 sec");
      clearInterval(timer);
  }, 3000);

  // global & globalThis
  global.myVar = "I am global!";
  console.log(globalThis.myVar);
  --------------------------------------------------------------------------------
- Best Practices:
  * Prefer modules over attaching things to globals
  * Be aware of CommonJS vs ESM differences
  * Avoid polluting global scope (hard to debug/test)
================================================================================
3. MODULES IN NODE.JS
================================================================================
- Meaning:
  * In Node.js, every file is treated as a separate module by default.
  * This prevents variables/functions from polluting the global scope.
  * To share code â†’ use exports (CommonJS or ES Modules).

--------------------------------------------------------------------------------
A) Without Modules (all code in one file)
--------------------------------------------------------------------------------
    // file: app.js
    const john = "john";
    const peter = "peter";

    function sayHi(name) {
        console.log(`Hello there ${name}`);
    }

    sayHi("Susan");
    sayHi(john);
    sayHi(peter);

- Problem:
  * Code is in a single file â†’ messy for big projects.
  * Hard to reuse code in other files.
  * No separation of concerns.

--------------------------------------------------------------------------------
B) With CommonJS Modules (default in Node)
--------------------------------------------------------------------------------
    // file: names.js
    const john = "john";
    const peter = "peter";
    module.exports = { john, peter };

    // file: utils.js
    function sayHi(name) {
        console.log(`Hello there ${name}`);   // Template Literal (backticks `...`)
                                                  `Hello there ${name}`

                                              - Backtick strings allow embedding variables with ${ }.
                                              - In Java, similar to string concatenation:
                                                    "Hello there " + name
    }
    module.exports = sayHi;

    // file: app.js
    const names = require("./names");
    const sayHi = require("./utils");

    sayHi("Susan");
    sayHi(names.john);
    sayHi(names.peter);

- Explanation:
  * `module.exports` â†’ defines what a file exports.
  * `require("./file")` â†’ imports that module into another file.
  * Now each file is focused and reusable.

--------------------------------------------------------------------------------
C) With ES Modules (modern standard)
--------------------------------------------------------------------------------
    // file: names.mjs
    export const john = "john";
    export const peter = "peter";

    // file: utils.mjs
    export function sayHi(name) {
        console.log(`Hello there ${name}`);
    }

    // file: app.mjs
    import { john, peter } from "./names.mjs";
    import { sayHi } from "./utils.mjs";

    sayHi("Susan");
    sayHi(john);
    sayHi(peter);

- Explanation:
  * `export` / `import` are ES6 standard.
  * Portable across browsers + Node.
  * Need `"type": "module"` in package.json or `.mjs` extension.

  --In Node.js, there are two module systems:

    CommonJS (CJS) â†’ the old default (require, module.exports).

    ES Modules (ESM) â†’ the modern standard (import, export).

    By default, Node treats .js files as CommonJS.
    If you want to use modern import / export syntax, you must either:

    Add "type": "module" in your package.json, or

    Rename files with .mjs extension.

    ðŸ‘‰ This tells Node: â€œtreat my files as ES modules instead of CommonJS.â€

--------------------------------------------------------------------------------
D) Difference (Summary)
--------------------------------------------------------------------------------
Aspect              | CommonJS (CJS)                | ES Modules (ESM)
--------------------|-------------------------------|------------------------------
Keywords            | require, module.exports       | import, export
File Extension      | .js (default)                 | .mjs OR "type":"module"
Loading             | Synchronous                   | Asynchronous
Where Used          | Node.js (older & current)     | Standard JS (Node + Browsers)
Interop             | Works with most npm packages  | Some packages now ESM only
Use Case            | Legacy / existing projects    | New, modern projects

--------------------------------------------------------------------------------
E) Best Practices
--------------------------------------------------------------------------------
* Always split code into modules for readability & reusability.
* Prefer ES Modules (`import/export`) for modern projects.
* Stick to CommonJS if project/codebase already uses it.
* Do not mix both styles unless absolutely required.
================================================================================

================================================================================
4. SPLITTING CODE INTO MODULES
--------------------------------------------------------------------------------
Step 1: names.js
    const secret = "SUPER SECRET"; // local
    const john = "john";
    const peter = "peter";
    module.exports = { john, peter };

Step 2: utils.js
    const sayHi = (name) => {
        console.log(`Hello there ${name}`);
    };
    module.exports = sayHi;

Step 3: app.js
    const names = require('./names');
    const sayHi = require('./utils');

    sayHi("Susan");
    sayHi(names.john);
    sayHi(names.peter);

Run:
    > node app.js

Output:
    Hello there Susan
    Hello there john
    Hello there peter

================================================================================
5. NODE MODULES: BASIC SETUP & EXECUTION
--------------------------------------------------------------------------------
- Create file: mind-grenade.js
Example:
    const num1 = 5;
    const num2 = 10;
    function addValues() {
        console.log(`The sum is: ${num1 + num2}`);
    }
    addValues();

- App.js usage:
    require('./mind-grenade');  // code executes immediately

Notes:
1. Works with both CommonJS and ES6 modules
2. Modules can execute code immediately
3. Node wraps module code in a function internally

================================================================================
6. USING BUILT-IN MODULES
--------------------------------------------------------------------------------
- Built-in modules: OS, Path, FS, HTTP, etc.
- Import syntax:
      const moduleName = require('module-name');  // No './' for built-ins
- Docs: https://nodejs.org/en/docs/

================================================================================
7. OS MODULE
--------------------------------------------------------------------------------
- Purpose: Info about OS and server
- Setup:
      const os = require('os');

Example:
    const user = os.userInfo();
    console.log(user);

    console.log(`System uptime: ${os.uptime()} seconds`);

    const currentOS = {
        name: os.type(),
        release: os.release(),
        totalMem: os.totalmem(),
        freeMem: os.freemem()
    };
    console.log(currentOS);

Notes:
- Provides user info, uptime, memory, OS type/release

================================================================================
8. PATH MODULE
--------------------------------------------------------------------------------
- Purpose: Work with file paths across platforms
- Setup:
      const path = require('path');

Useful methods:
1. path.sep â†’ platform-specific separator
2. path.join(...) â†’ joins segments, normalizes path
3. path.basename(filePath) â†’ returns last portion (filename)
4. path.resolve(...) â†’ returns absolute path

Example:
    const filePath = path.join('content', 'subfolder', 'test.txt');
    console.log(filePath);
    console.log(path.basename(filePath));
    console.log(path.resolve(__dirname, 'content', 'subfolder', 'test.txt'));

================================================================================
9. FILE SYSTEM MODULE (FS)
--------------------------------------------------------------------------------
- Purpose: Interact with files (read/write/append)
- Setup:
      const fs = require('fs');

--------------------------------------------------------------------------------
9a. Synchronous (Blocking)
Example:
    const first = fs.readFileSync('./content/first.txt', 'utf8');
    const second = fs.readFileSync('./content/second.txt', 'utf8');

    fs.writeFileSync('./content/result-sync.txt',
        `Here is the result: ${first}, ${second}`);

- Append: fs.writeFileSync('file.txt', data, { flag: 'a' })

--------------------------------------------------------------------------------
9b. Asynchronous (Non-Blocking)
Example:
    fs.readFile('./content/first.txt', 'utf8', (err, result) => {
        if(err) return console.log(err);
        const first = result;

        fs.readFile('./content/second.txt', 'utf8', (err, result) => {
            if(err) return console.log(err);
            const second = result;

            fs.writeFile('./content/result-async.txt',
                `Here is the result: ${first}, ${second}`,
                (err) => {
                    if(err) return console.log(err);
                    console.log('File written successfully');
                });
        });
    });

Notes:
- Async prevents blocking, handles multiple users
- Nested callbacks â†’ "Callback Hell"
- Use Promises/async-await for readability

================================================================================
10. SYNCHRONOUS VS ASYNCHRONOUS
--------------------------------------------------------------------------------
- Blocking (Sync): Node waits for task to finish
- Non-blocking (Async): Node offloads task, continues execution

Example:
    console.log('Start');
    fs.writeFileSync(...);
    console.log('Done with task');
    console.log('Next task');

    console.log('Start');
    fs.writeFile(..., callback);
    console.log('Next task');

- Async recommended for I/O-heavy operations

================================================================================
11. HTTP MODULE: BASIC SERVER SETUP
--------------------------------------------------------------------------------
- Purpose: Web server + handle HTTP requests/responses
- Built-in module: http
- Minimal coverage now; details later

Setup:
    const http = require('http');
    const server = http.createServer((req, res) => {
        res.write('Welcome to our homepage');
        res.end();
    });

    server.listen(5000);

Notes:
1. req â†’ request object
2. res â†’ response object
3. Server stays active
4. Run: node app.js
5. Visit: http://localhost:5000

--------------------------------------------------------------------------------
11a. Routing Example
const http = require('http');

const server = http.createServer((req, res) => {
    // Home page
    if (req.url === '/') {
        res.end('Welcome to our homepage');
    }
    // About page
    else if (req.url === '/about') {
        res.end('Here is our short history');
    }
    // 404 - Page not found
    else {
        res.end(`
            <p>We can't seem to find the page you're looking for.</p>
            <a href="/">Go back home</a>
        `);
    }
});

// Start the server on port 5000
server.listen(5000, () => {
    console.log('Server is listening on http://localhost:5000');
});

Notes:
- Must send only one response per request
- Fix multiple responses:
    1. Add return after res.end()
    2. Or use if-else if-else structure

================================================================================
12. NODE PACKAGE MANAGER (NPM)
--------------------------------------------------------------------------------
- Installed with Node.js
- Enables:
    1. Reuse own code
    2. Use code by others
    3. Share own solutions
- Website: https://www.npmjs.com

Concepts:
- Package / Module / Dependency = shareable JS code
- No quality control: check weekly downloads for reliability

Installing Packages:
- Check NPM version:
      npm --version  // or npm -v

- Local dependency:
      npm install <package-name>  // or npm i <package-name>

- Global dependency:
      npm install -g <package-name>
      // macOS may require: sudo npm install -g <package-name>

- Recommended: Local dependencies; use NPX for running packages without global install

Example Packages:
- Bootstrap, Lodash, Express
- Install locally: npm install express
- Install globally: npm install -g create-react-app

Notes:
1. Local â†’ node_modules folder in project
2. Global â†’ system-wide directory
3. NPX reduces need for global install

================================================================================
13. KEY TAKEAWAYS
--------------------------------------------------------------------------------
1. Each file is a Node module; only exported values accessible
2. __dirname, __filename, process, console are common globals
3. Modules execute code immediately if invoked
4. Built-in modules are powerful: os, path, fs, http
5. FS module:
    - Sync blocks execution
    - Async prevents blocking
    - Use async/await to avoid callback hell
6. HTTP Module:
    - req.url used for routing
    - Must return after sending response or use if-else
7. NPM:
    - Install local/global packages
    - Popularity indicates reliability
    - NPX reduces need for global install
8. Non-blocking async is essential for scalable Node servers

================================================================================
================================================================================
14. NPM & PACKAGE.JSON
================================================================================
- Purpose: Manage project dependencies and metadata.
- npm comes with Node.js by default.

PACKAGE.JSON - NODE.JS PROJECT MANIFEST
--------------------------------------

1. Purpose:
   - Holds metadata about the project: name, version, author, license, etc.
   - Lists dependencies: libraries required for the project (e.g., express, lodash).
   - Defines scripts: commands runnable via "npm run <script>".
   - Specifies Node.js version compatibility.

2. Example:

{
    "name": "my-node-app",
    "version": "1.0.0",
    "description": "A simple Node.js project",
    "main": "index.js",
    "scripts": {
        "start": "node index.js",
        "test": "echo \"No tests defined\" && exit 0"
    },
    "author": "Ajay Sharma",
    "license": "MIT",
    "dependencies": {
        "express": "^4.18.2"
    },
    "devDependencies": {
        "nodemon": "^3.0.2"
    }
}


--------------------------------------------------------------------------------
14a. Creating package.json
--------------------------------------------------------------------------------
- package.json is a manifest file storing important project info.
- Three ways to create it:
  1. Manual: create file in project root, add properties manually (time-consuming)
  2. Step-by-step: `npm init` â†’ prompts questions
  3. Default setup: `npm init -y` â†’ generates default file automatically
- Properties include: name, version, description, main, scripts, author, license, dependencies

--------------------------------------------------------------------------------
14b. Installing Local Packages
--------------------------------------------------------------------------------
- Syntax: `npm i <package-name>` (or `npm install <package-name>`)
- Example: `npm i lodash`
- Dependencies are added in `package.json` under `"dependencies"`
- Node creates `node_modules` folder to store installed packages
- Some packages have their own dependencies; npm installs them automatically
- Example: Installing Bootstrap also installs jQuery and Popper.js

--------------------------------------------------------------------------------
14c. Using Installed Packages
--------------------------------------------------------------------------------
- Assign the package to a variable using `require`:
      const _ = require('lodash');
- Example usage:
      const items = [[1, 2], [3, 4]];
      const newItems = _.flattenDeep(items);
      console.log(newItems);  // Output: [1, 2, 3, 4]
- Note: External packages must be installed before use
- Node built-in modules (fs, http, path, etc.) donâ€™t need installation

--------------------------------------------------------------------------------
15. Key Takeaways
--------------------------------------------------------------------------------
1. `package.json` stores metadata and project dependencies.
2. `npm init` creates package.json (step-by-step or default `-y` flag)
3. `npm i <package>` installs local packages
4. Dependencies appear in `node_modules` and in package.json
5. Some packages install additional dependencies automatically
6. Use `require('<package>')` to access installed packages in code
7. Having package.json is crucial for sharing projects with others


================================================================================
16. SHARING PROJECTS & PACKAGE.JSON IMPORTANCE
================================================================================
- Purpose: Understand why package.json is crucial when sharing projects

--------------------------------------------------------------------------------
16a. Avoid Pushing node_modules
--------------------------------------------------------------------------------
- node_modules can be very large (10MB+)
- Use `.gitignore` to exclude `node_modules` from GitHub
- Only share code + package.json
- Git ignores files listed in `.gitignore`

--------------------------------------------------------------------------------
16b. Cloning & Installing Dependencies
--------------------------------------------------------------------------------
- Workflow:
  1. Clone repo from GitHub
  2. Run `npm install`
- npm reads dependencies in package.json
- Automatically installs required node_modules
- Ensures collaborators have correct dependencies without pushing huge folders
- Common in React projects and Node apps

--------------------------------------------------------------------------------
16c. Dev Dependencies
--------------------------------------------------------------------------------
- Command: `npm i nodemon -D`  (or `--save-dev`)
- Purpose:
  - Packages used only during development (not production)
  - Examples: nodemon, testing libraries, linters, formatters
- Production uses only runtime dependencies
- DevDependencies stored separately in package.json

-D or --save-dev â†’ tells npm to put it in "devDependencies" instead of "dependencies"

Why separate them?

Smaller production build â†’ no extra packages you donâ€™t need at runtime

Clear project structure â†’ everyone knows which packages are for coding vs running the app
--------------------------------------------------------------------------------
16d. Scripts in package.json
--------------------------------------------------------------------------------
- Scripts object allows custom commands
- Example:
      "scripts": {
          "start": "node app.js",
          "dev": "nodemon app.js"
      }
- Run commands:
  - `npm start` â†’ runs `start` script
  - `npm run dev` â†’ runs `dev` script
- nodemon automatically restarts app on file changes

--------------------------------------------------------------------------------
16e. Uninstalling Packages
--------------------------------------------------------------------------------
- Command: `npm uninstall <package-name>`
- Removes package from node_modules and updates package.json
- Nuclear approach:
  1. Delete node_modules
  2. Delete package-lock.json
  3. Run `npm install` to reinstall dependencies from scratch
- Useful when dependencies become inconsistent or corrupted
- Example: removing Bootstrap after installation

--------------------------------------------------------------------------------
17. Key Takeaways
--------------------------------------------------------------------------------
1. `.gitignore` prevents pushing node_modules to GitHub
2. package.json + npm install ensures collaborators can run your project
3. DevDependencies are for development-only tools
4. Scripts in package.json simplify running commands
5. npm uninstall and nuclear approach help manage/remove packages safely

Example .gitignore

Where to create/write .gitignore

Go to the root of your project folder (the same folder where package.json is).

Create a file named .gitignore (literally with a dot at the beginning).

In VS Code: Right-click â†’ New File â†’ name it .gitignore

In terminal:

touch .gitignore

Add the files/folders you want Git to ignore. Example for Node.js:
# Node.js dependencies
node_modules/

# Logs
logs/
*.log

# Environment variables
.env

# OS files
.DS_Store
Thumbs.db

================================================================================
18. GLOBAL PACKAGE INSTALLATION & NPX
================================================================================
- Command for global install: `npm install -g <packageName>`
- Global packages can be used in any project
- Example: nodemon installed globally â†’ can run `nodemon app.js` anywhere

--------------------------------------------------------------------------------
18a. Use Cases for Global Packages
--------------------------------------------------------------------------------
- Useful for CLI tools (e.g., Gatsby CLI, Create React App)
- Typically frameworks or tools used across multiple projects
- NPX reduces need for global installs
    - Example: `npx create-react-app my-app`
- Personal preference: avoid global packages to reduce student setup issues
- Recommended: use NPX or local dependency instead of global

--------------------------------------------------------------------------------
18b. NPX (Node Package Runner)
--------------------------------------------------------------------------------
- Introduced in NPM 5.2+
- Allows executing CLI tools without installing globally
- Example:
    - `npx create-react-app <project-name>`
    - Runs the tool directly from NPM registry

--------------------------------------------------------------------------------
19. PACKAGE-LOCK.JSON
--------------------------------------------------------------------------------
- Purpose: lock exact versions of dependencies & sub-dependencies
- Ensures everyone using your project has identical setup
- Prevents breaking changes due to updated versions of dependencies
- Three version components:
    1. **Major** â†’ breaking changes
    2. **Minor** â†’ backward compatible changes
    3. **Patch** â†’ bug fixes only
- Acts as a contract between package authors and users
- Important when publishing your own packages

--------------------------------------------------------------------------------
20. ADDITIONAL RESOURCES
--------------------------------------------------------------------------------
- Official guide: "The Basics of Package.json"
- Covers all fields: name, version, description, scripts, dependencies, etc.


