-------------------------------------------------------------
NODE.JS: INTRODUCTION & ORIGINS
-------------------------------------------------------------

1. What is Node.js?
-------------------
- Node.js = Environment to run JavaScript outside of the browser.
- Created in 2009 by Ryan Dahl.
- Built on top of Chrome’s V8 JavaScript engine.
- Purpose: Run JS on the server, not just in browsers.

2. V8 JavaScript Engine
-----------------------
- Every browser has an engine to compile JS → machine code.
- Chrome uses **V8 engine** (fast, optimized).
- Node.js takes V8 out of Chrome and runs it standalone.
- This allows JavaScript to run directly on the operating system.

3. Why Node.js?
---------------
3.1 Community:
    - Large open-source community.
    - Many libraries/packages available via npm.
    - Saves development time.

3.2 Full-Stack Development:
    - Frontend + Backend both in JavaScript.
    - Easier for developers to build full apps with one language.
    - Eliminates "language switching" between client and server.

-------------------------------------------------------------
NODE.JS: REQUIREMENTS, DIFFERENCES & INSTALLATION
-------------------------------------------------------------

1. Course_Udemy Requirements
----------------------
- Prerequisites:
  * Basic HTML
  * Simple CSS
  * General understanding of JavaScript:
      - ES6 features
      - Callbacks
      - Promises
      - async/await
- Instructor will not cover deep JS basics (focus = Node.js).
- If needed: Brush up using "Coding Addict" YouTube channel,
  especially the "JS Nuggets" playlist (covers ES6 & async JS).

2. Browser JS vs Node.js
------------------------
2.1 What Node.js does NOT have:
    - No browser APIs (no DOM, no window object, no fetch,
      no geolocation, etc.)
    - Node apps = pure logic, not interactive UIs.
    - You won’t use `document.querySelector` in Node.

2.2 What Node.js DOES provide:
    - File system access
    - Operating system info
    - Responding to network requests
    - Modules system (CommonJS by default)

2.3 Versions:
    - Node apps depend only on the Node version used.
    - Different from browsers (where features depend on user’s browser).
    - You can keep running your app on the same Node version
      without worrying about browser compatibility.

2.4 Modules in Node:
    - Available by default.
    - Node uses **CommonJS module system**.
    - Concept is similar to ES6 modules, but syntax differs.
      Example:
        const fs = require('fs');   // CommonJS
        import fs from 'fs';        // ES6 (browser style)

3. Installing Node.js
---------------------
3.1 Steps:
    - Visit: https://nodejs.org
    - Choose **LTS version** (Long Term Support).
    - Download & run installer.
    - Click through prompts (Yes/Agree/Install).
    - Enter system password if required.
    - After install, remove installer file if you want.

3.2 Verify Installation:
    - Open terminal.
    - Run: node --version
    - Expected: shows version number (e.g., v14.x, v18.x, v20.x).

3.3 Troubleshooting:
    - If version does not appear, installation failed.
    - Instructor cannot debug your local setup.
    - Use Google/search engines for specific errors.

3.4 LTS vs Current:
    - Node.js offers two releases:
        a) **LTS** = Long Term Support (recommended for production).
        b) Current = Latest features, less stable for production.
    - Always prefer LTS for stability.
    - If your version is newer than instructor’s, no issue.
    - Course_Udemy content will work fine with future LTS versions.


================================================================================
INDEX
================================================================================
1. Creating a Node Project
2. Globals in Node.js
3. Modules in Node.js
4. Splitting Code into Modules
5. Node Modules: Basic Setup & Execution
6. Using Built-in Modules
7. OS Module
8. Path Module
9. File System (FS) Module
10. Synchronous vs Asynchronous
11. HTTP Module: Basic Server Setup
12. Node Package Manager (NPM)
13. Key Takeaways
================================================================================

1. CREATING A NODE PROJECT
--------------------------------------------------------------------------------
- Create folder "tutorial" → open with Code.
- Create file "app.js". Node runs JS outside browser.

Example:
    const amount = 12;

    if (amount < 10) {
        console.log("small number");
    } else {
        console.log("large number");
    }

    console.log(`hey, it's my first node app`);

Run in terminal:
    > node app.js

- From any directory use full path:
    > node /Users/username/Desktop/tutorial/app.js

- In VS Code integrated terminal (Ctrl + ~):
    > node app.js

================================================================================
2. GLOBALS IN NODE.JS
--------------------------------------------------------------------------------
- Meaning:
  "Globals" are identifiers Node provides automatically.
  You can use them anywhere without importing.
  They belong to Node's global object (`global` / `globalThis`).

- Important Note:
  Node wraps each file in a function.
  -> Top-level variables (let/const/var) are NOT global.
  -> True global only if attached to `global.myVar`.

- Common Globals:
  __dirname     : Directory path of current module (CommonJS only)
  __filename    : File path of current module (CommonJS only)
  require       : Import CommonJS modules
  module/exports: Info & export object for current module
  process       : Runtime/env info (env vars, args, exit, etc.)
  console       : Global logging methods
  setTimeout    : Run function after delay (clearTimeout to stop)
  setInterval   : Run repeatedly after interval (clearInterval to stop)
  global        : Node's global object
  globalThis    : Standard global object (works in Node & browsers)

- Example:
  6. Example using All Common Globals
  --------------------------------------------------------------------------------
  const path = require("path");   // <-- using require (CommonJS)

  // __dirname & __filename

  console.log("Directory:", __dirname);
  console.log("File:", __filename);

  // module / exports
  console.log("Module Info:", module.id);

  // process (env + args)
  console.log("Node Version:", process.version);
  console.log("Arguments:", process.argv);

  // console
  console.log("Logging something with console.log");

  // setTimeout + setInterval
  const timer = setInterval(() => {
      console.log("Interval running...");
  }, 1000);

  setTimeout(() => {
      console.log("Stopping interval after 3 sec");
      clearInterval(timer);
  }, 3000);

  // global & globalThis
  global.myVar = "I am global!";
  console.log(globalThis.myVar);
  --------------------------------------------------------------------------------
- Best Practices:
  * Prefer modules over attaching things to globals
  * Be aware of CommonJS vs ESM differences
  * Avoid polluting global scope (hard to debug/test)
================================================================================
3. MODULES IN NODE.JS
================================================================================
- Meaning:
  * In Node.js, every file is treated as a separate module by default.
  * This prevents variables/functions from polluting the global scope.
  * To share code → use exports (CommonJS or ES Modules).

--------------------------------------------------------------------------------
A) Without Modules (all code in one file)
--------------------------------------------------------------------------------
    // file: app.js
    const john = "john";
    const peter = "peter";

    function sayHi(name) {
        console.log(`Hello there ${name}`);
    }

    sayHi("Susan");
    sayHi(john);
    sayHi(peter);

- Problem:
  * Code is in a single file → messy for big projects.
  * Hard to reuse code in other files.
  * No separation of concerns.

--------------------------------------------------------------------------------
B) With CommonJS Modules (default in Node)
--------------------------------------------------------------------------------
    // file: names.js
    const john = "john";
    const peter = "peter";
    module.exports = { john, peter };

    // file: utils.js
    function sayHi(name) {
        console.log(`Hello there ${name}`);   // Template Literal (backticks `...`)
                                                  `Hello there ${name}`

                                              - Backtick strings allow embedding variables with ${ }.
                                              - In Java, similar to string concatenation:
                                                    "Hello there " + name
    }
    module.exports = sayHi;

    // file: app.js
    const names = require("./names");
    const sayHi = require("./utils");

    sayHi("Susan");
    sayHi(names.john);
    sayHi(names.peter);

- Explanation:
  * `module.exports` → defines what a file exports.
  * `require("./file")` → imports that module into another file.
  * Now each file is focused and reusable.

--------------------------------------------------------------------------------
C) With ES Modules (modern standard)
--------------------------------------------------------------------------------
    // file: names.mjs
    export const john = "john";
    export const peter = "peter";

    // file: utils.mjs
    export function sayHi(name) {
        console.log(`Hello there ${name}`);
    }

    // file: app.mjs
    import { john, peter } from "./names.mjs";
    import { sayHi } from "./utils.mjs";

    sayHi("Susan");
    sayHi(john);
    sayHi(peter);

- Explanation:
  * `export` / `import` are ES6 standard.
  * Portable across browsers + Node.
  * Need `"type": "module"` in package.json or `.mjs` extension.

  --In Node.js, there are two module systems:

    CommonJS (CJS) → the old default (require, module.exports).

    ES Modules (ESM) → the modern standard (import, export).

    By default, Node treats .js files as CommonJS.
    If you want to use modern import / export syntax, you must either:

    Add "type": "module" in your package.json, or

    Rename files with .mjs extension.

    👉 This tells Node: “treat my files as ES modules instead of CommonJS.”

--------------------------------------------------------------------------------
D) Difference (Summary)
--------------------------------------------------------------------------------
Aspect              | CommonJS (CJS)                | ES Modules (ESM)
--------------------|-------------------------------|------------------------------
Keywords            | require, module.exports       | import, export
File Extension      | .js (default)                 | .mjs OR "type":"module"
Loading             | Synchronous                   | Asynchronous
Where Used          | Node.js (older & current)     | Standard JS (Node + Browsers)
Interop             | Works with most npm packages  | Some packages now ESM only
Use Case            | Legacy / existing projects    | New, modern projects

--------------------------------------------------------------------------------
E) Best Practices
--------------------------------------------------------------------------------
* Always split code into modules for readability & reusability.
* Prefer ES Modules (`import/export`) for modern projects.
* Stick to CommonJS if project/codebase already uses it.
* Do not mix both styles unless absolutely required.
================================================================================

================================================================================
4. SPLITTING CODE INTO MODULES
--------------------------------------------------------------------------------
Step 1: names.js
    const secret = "SUPER SECRET"; // local
    const john = "john";
    const peter = "peter";
    module.exports = { john, peter };

Step 2: utils.js
    const sayHi = (name) => {
        console.log(`Hello there ${name}`);
    };
    module.exports = sayHi;

Step 3: app.js
    const names = require('./names');
    const sayHi = require('./utils');

    sayHi("Susan");
    sayHi(names.john);
    sayHi(names.peter);

Run:
    > node app.js

Output:
    Hello there Susan
    Hello there john
    Hello there peter

================================================================================
5. NODE MODULES: BASIC SETUP & EXECUTION
--------------------------------------------------------------------------------
- Create file: mind-grenade.js
Example:
    const num1 = 5;
    const num2 = 10;
    function addValues() {
        console.log(`The sum is: ${num1 + num2}`);
    }
    addValues();

- App.js usage:
    require('./mind-grenade');  // code executes immediately

Notes:
1. Works with both CommonJS and ES6 modules
2. Modules can execute code immediately
3. Node wraps module code in a function internally

================================================================================
6. USING BUILT-IN MODULES
--------------------------------------------------------------------------------
- Built-in modules: OS, Path, FS, HTTP, etc.
- Import syntax:
      const moduleName = require('module-name');  // No './' for built-ins
- Docs: https://nodejs.org/en/docs/

================================================================================
7. OS MODULE
--------------------------------------------------------------------------------
- Purpose: Info about OS and server
- Setup:
      const os = require('os');

Example:
    const user = os.userInfo();
    console.log(user);

    console.log(`System uptime: ${os.uptime()} seconds`);

    const currentOS = {
        name: os.type(),
        release: os.release(),
        totalMem: os.totalmem(),
        freeMem: os.freemem()
    };
    console.log(currentOS);

Notes:
- Provides user info, uptime, memory, OS type/release

================================================================================
8. PATH MODULE
--------------------------------------------------------------------------------
- Purpose: Work with file paths across platforms
- Setup:
      const path = require('path');

Useful methods:
1. path.sep → platform-specific separator
2. path.join(...) → joins segments, normalizes path
3. path.basename(filePath) → returns last portion (filename)
4. path.resolve(...) → returns absolute path

Example:
    const filePath = path.join('content', 'subfolder', 'test.txt');
    console.log(filePath);
    console.log(path.basename(filePath));
    console.log(path.resolve(__dirname, 'content', 'subfolder', 'test.txt'));

================================================================================
9. FILE SYSTEM MODULE (FS)
--------------------------------------------------------------------------------
- Purpose: Interact with files (read/write/append)
- Setup:
      const fs = require('fs');

--------------------------------------------------------------------------------
9a. Synchronous (Blocking)
Example:
    const first = fs.readFileSync('./content/first.txt', 'utf8');
    const second = fs.readFileSync('./content/second.txt', 'utf8');

    fs.writeFileSync('./content/result-sync.txt',
        `Here is the result: ${first}, ${second}`);

- Append: fs.writeFileSync('file.txt', data, { flag: 'a' })

--------------------------------------------------------------------------------
9b. Asynchronous (Non-Blocking)
Example:
    fs.readFile('./content/first.txt', 'utf8', (err, result) => {
        if(err) return console.log(err);
        const first = result;

        fs.readFile('./content/second.txt', 'utf8', (err, result) => {
            if(err) return console.log(err);
            const second = result;

            fs.writeFile('./content/result-async.txt',
                `Here is the result: ${first}, ${second}`,
                (err) => {
                    if(err) return console.log(err);
                    console.log('File written successfully');
                });
        });
    });

Notes:
- Async prevents blocking, handles multiple users
- Nested callbacks → "Callback Hell"
- Use Promises/async-await for readability

================================================================================
10. SYNCHRONOUS VS ASYNCHRONOUS
--------------------------------------------------------------------------------
- Blocking (Sync): Node waits for task to finish
- Non-blocking (Async): Node offloads task, continues execution

Example:
    console.log('Start');
    fs.writeFileSync(...);
    console.log('Done with task');
    console.log('Next task');

    console.log('Start');
    fs.writeFile(..., callback);
    console.log('Next task');

- Async recommended for I/O-heavy operations

================================================================================
11. HTTP MODULE: BASIC SERVER SETUP
--------------------------------------------------------------------------------
- Purpose: Web server + handle HTTP requests/responses
- Built-in module: http
- Minimal coverage now; details later

Setup:
    const http = require('http');
    const server = http.createServer((req, res) => {
        res.write('Welcome to our homepage');
        res.end();
    });

    server.listen(5000);

Notes:
1. req → request object
2. res → response object
3. Server stays active
4. Run: node app.js
5. Visit: http://localhost:5000

--------------------------------------------------------------------------------
11a. Routing Example
const http = require('http');

const server = http.createServer((req, res) => {
    // Home page
    if (req.url === '/') {
        res.end('Welcome to our homepage');
    }
    // About page
    else if (req.url === '/about') {
        res.end('Here is our short history');
    }
    // 404 - Page not found
    else {
        res.end(`
            <p>We can't seem to find the page you're looking for.</p>
            <a href="/">Go back home</a>
        `);
    }
});

// Start the server on port 5000
server.listen(5000, () => {
    console.log('Server is listening on http://localhost:5000');
});

Notes:
- Must send only one response per request
- Fix multiple responses:
    1. Add return after res.end()
    2. Or use if-else if-else structure

================================================================================
12. NODE PACKAGE MANAGER (NPM)
--------------------------------------------------------------------------------
- Installed with Node.js
- Enables:
    1. Reuse own code
    2. Use code by others
    3. Share own solutions
- Website: https://www.npmjs.com

Concepts:
- Package / Module / Dependency = shareable JS code
- No quality control: check weekly downloads for reliability

Installing Packages:
- Check NPM version:
      npm --version  // or npm -v

- Local dependency:
      npm install <package-name>  // or npm i <package-name>

- Global dependency:
      npm install -g <package-name>
      // macOS may require: sudo npm install -g <package-name>

- Recommended: Local dependencies; use NPX for running packages without global install

Example Packages:
- Bootstrap, Lodash, Express
- Install locally: npm install express
- Install globally: npm install -g create-react-app

Notes:
1. Local → node_modules folder in project
2. Global → system-wide directory
3. NPX reduces need for global install

================================================================================
13. KEY TAKEAWAYS
--------------------------------------------------------------------------------
1. Each file is a Node module; only exported values accessible
2. __dirname, __filename, process, console are common globals
3. Modules execute code immediately if invoked
4. Built-in modules are powerful: os, path, fs, http
5. FS module:
    - Sync blocks execution
    - Async prevents blocking
    - Use async/await to avoid callback hell
6. HTTP Module:
    - req.url used for routing
    - Must return after sending response or use if-else
7. NPM:
    - Install local/global packages
    - Popularity indicates reliability
    - NPX reduces need for global install
8. Non-blocking async is essential for scalable Node servers

================================================================================
================================================================================
14. NPM & PACKAGE.JSON
================================================================================
- Purpose: Manage project dependencies and metadata.
- npm comes with Node.js by default.

PACKAGE.JSON - NODE.JS PROJECT MANIFEST
--------------------------------------

1. Purpose:
   - Holds metadata about the project: name, version, author, license, etc.
   - Lists dependencies: libraries required for the project (e.g., express, lodash).
   - Defines scripts: commands runnable via "npm run <script>".
   - Specifies Node.js version compatibility.

2. Example:

{
    "name": "my-node-app",
    "version": "1.0.0",
    "description": "A simple Node.js project",
    "main": "index.js",
    "scripts": {
        "start": "node index.js",
        "test": "echo \"No tests defined\" && exit 0"
    },
    "author": "Ajay Sharma",
    "license": "MIT",
    "dependencies": {
        "express": "^4.18.2"
    },
    "devDependencies": {
        "nodemon": "^3.0.2"
    }
}


--------------------------------------------------------------------------------
14a. Creating package.json
--------------------------------------------------------------------------------
- package.json is a manifest file storing important project info.
- Three ways to create it:
  1. Manual: create file in project root, add properties manually (time-consuming)
  2. Step-by-step: `npm init` → prompts questions
  3. Default setup: `npm init -y` → generates default file automatically
- Properties include: name, version, description, main, scripts, author, license, dependencies

--------------------------------------------------------------------------------
14b. Installing Local Packages
--------------------------------------------------------------------------------
- Syntax: `npm i <package-name>` (or `npm install <package-name>`)
- Example: `npm i lodash`
- Dependencies are added in `package.json` under `"dependencies"`
- Node creates `node_modules` folder to store installed packages
- Some packages have their own dependencies; npm installs them automatically
- Example: Installing Bootstrap also installs jQuery and Popper.js

--------------------------------------------------------------------------------
14c. Using Installed Packages
--------------------------------------------------------------------------------
- Assign the package to a variable using `require`:
      const _ = require('lodash');
- Example usage:
      const items = [[1, 2], [3, 4]];
      const newItems = _.flattenDeep(items);
      console.log(newItems);  // Output: [1, 2, 3, 4]
- Note: External packages must be installed before use
- Node built-in modules (fs, http, path, etc.) don’t need installation

--------------------------------------------------------------------------------
15. Key Takeaways
--------------------------------------------------------------------------------
1. `package.json` stores metadata and project dependencies.
2. `npm init` creates package.json (step-by-step or default `-y` flag)
3. `npm i <package>` installs local packages
4. Dependencies appear in `node_modules` and in package.json
5. Some packages install additional dependencies automatically
6. Use `require('<package>')` to access installed packages in code
7. Having package.json is crucial for sharing projects with others


================================================================================
16. SHARING PROJECTS & PACKAGE.JSON IMPORTANCE
================================================================================
- Purpose: Understand why package.json is crucial when sharing projects

--------------------------------------------------------------------------------
16a. Avoid Pushing node_modules
--------------------------------------------------------------------------------
- node_modules can be very large (10MB+)
- Use `.gitignore` to exclude `node_modules` from GitHub
- Only share code + package.json
- Git ignores files listed in `.gitignore`

--------------------------------------------------------------------------------
16b. Cloning & Installing Dependencies
--------------------------------------------------------------------------------
- Workflow:
  1. Clone repo from GitHub
  2. Run `npm install`
- npm reads dependencies in package.json
- Automatically installs required node_modules
- Ensures collaborators have correct dependencies without pushing huge folders
- Common in React projects and Node apps

--------------------------------------------------------------------------------
16c. Dev Dependencies
--------------------------------------------------------------------------------
- Command: `npm i nodemon -D`  (or `--save-dev`)
- Purpose:
  - Packages used only during development (not production)
  - Examples: nodemon, testing libraries, linters, formatters
- Production uses only runtime dependencies
- DevDependencies stored separately in package.json

-D or --save-dev → tells npm to put it in "devDependencies" instead of "dependencies"

Why separate them?

Smaller production build → no extra packages you don’t need at runtime

Clear project structure → everyone knows which packages are for coding vs running the app
--------------------------------------------------------------------------------
16d. Scripts in package.json
--------------------------------------------------------------------------------
- Scripts object allows custom commands
- Example:
      "scripts": {
          "start": "node app.js",
          "dev": "nodemon app.js"
      }
- Run commands:
  - `npm start` → runs `start` script
  - `npm run dev` → runs `dev` script
- nodemon automatically restarts app on file changes

--------------------------------------------------------------------------------
16e. Uninstalling Packages
--------------------------------------------------------------------------------
- Command: `npm uninstall <package-name>`
- Removes package from node_modules and updates package.json
- Nuclear approach:
  1. Delete node_modules
  2. Delete package-lock.json
  3. Run `npm install` to reinstall dependencies from scratch
- Useful when dependencies become inconsistent or corrupted
- Example: removing Bootstrap after installation

--------------------------------------------------------------------------------
17. Key Takeaways
--------------------------------------------------------------------------------
1. `.gitignore` prevents pushing node_modules to GitHub
2. package.json + npm install ensures collaborators can run your project
3. DevDependencies are for development-only tools
4. Scripts in package.json simplify running commands
5. npm uninstall and nuclear approach help manage/remove packages safely

Example .gitignore

Where to create/write .gitignore

Go to the root of your project folder (the same folder where package.json is).

Create a file named .gitignore (literally with a dot at the beginning).

In VS Code: Right-click → New File → name it .gitignore

In terminal:

touch .gitignore

Add the files/folders you want Git to ignore. Example for Node.js:
# Node.js dependencies
node_modules/

# Logs
logs/
*.log

# Environment variables
.env

# OS files
.DS_Store
Thumbs.db

================================================================================
18. GLOBAL PACKAGE INSTALLATION & NPX
================================================================================
- Command for global install: `npm install -g <packageName>`
- Global packages can be used in any project
- Example: nodemon installed globally → can run `nodemon app.js` anywhere

--------------------------------------------------------------------------------
18a. Use Cases for Global Packages
--------------------------------------------------------------------------------
- Useful for CLI tools (e.g., Gatsby CLI, Create React App)
- Typically frameworks or tools used across multiple projects
- NPX reduces need for global installs
    - Example: `npx create-react-app my-app`
- Personal preference: avoid global packages to reduce student setup issues
- Recommended: use NPX or local dependency instead of global

--------------------------------------------------------------------------------
18b. NPX (Node Package Runner)
--------------------------------------------------------------------------------
- Introduced in NPM 5.2+
- Allows executing CLI tools without installing globally
- Example:
    - `npx create-react-app <project-name>`
    - Runs the tool directly from NPM registry

--------------------------------------------------------------------------------
19. PACKAGE-LOCK.JSON
--------------------------------------------------------------------------------
- Purpose: lock exact versions of dependencies & sub-dependencies
- Ensures everyone using your project has identical setup
- Prevents breaking changes due to updated versions of dependencies
- Three version components:
    1. **Major** → breaking changes
    2. **Minor** → backward compatible changes
    3. **Patch** → bug fixes only
- Acts as a contract between package authors and users
- Important when publishing your own packages

--------------------------------------------------------------------------------
20. ADDITIONAL RESOURCES
--------------------------------------------------------------------------------
- Official guide: "The Basics of Package.json"
- Covers all fields: name, version, description, scripts, dependencies, etc.


