TOPIC: HTTP Methods in Express

1) Introduction:
   - GET → default browser method → used to read data.
   - POST → insert data (example: add an order).
   - PUT → update data.
   - DELETE → remove data.
   - Note: In this example, **data is not persisted** (no database).
   - Rationale: Using file system is optional, but mostly devs will use a DB anyway.

2) Data Setup (data.js):
   const people = [
     { id: 1, name: 'John' },
     { id: 2, name: 'Jane' },
     { id: 3, name: 'Jack' },
     { id: 4, name: 'Jill' }
   ];
   module.exports = { people };

3) Importing Data in app.js:
   - Use `let` to allow modification of array later.
   let { people } = require('./data');

4) GET Method – Read Data (app.js):
   app.get('/api/people', (req, res) => {
     res.status(200).json({
       success: true,   // indicates request success
       data: people     // returns current array
     });
   });

5) Browser/Test:
   - URL: http://localhost:5000/api/people
   - Response:
     {
       "success": true,
       "data": [
         { "id": 1, "name": "John" },
         { "id": 2, "name": "Jane" },
         { "id": 3, "name": "Jack" },
         { "id": 4, "name": "Jill" }
       ]
     }
   - Default GET method in browser returns this.
   - Accessing homepage without route → "Cannot GET /" → 404.

6) Notes / Teacher’s Insights:
   - Browser always performs GET by default.
   - Each route is exact → must request `/api/people`.
   - Status code 200 → request successful.
   - Structured JSON response recommended (`success`, `data`).
   - `people` array is **in-memory**, not persisted to DB yet.
   - Later methods (POST, PUT, DELETE) will modify this array in-memory.
   - This is the foundation for learning RESTful APIs in Express.
-------------------------------------------------------------------


TOPIC: POST Method in Express (Adding Data)

1) Introduction:
   - GET → read data (default browser method)
   - POST → insert/add data onto the server
   - Browser cannot natively make POST requests
     → need tools like **Postman**, **Insomnia**, or a frontend app.
   - Two flavors for POST requests will be demonstrated:
     1) Traditional HTML form submission
     2) Using JavaScript fetch/AJAX requests

2) Preparing Static Assets for Testing:
   - Create folder: methods.public
   - Add files:
     - index.html
     - JavaScript, HTML, CSS as needed
   - Purpose: frontend form/app to test POST requests

3) Setting Up Static Folder in Express (app.js):
   // Assets – serve static files
   app.use(express.static('./methods.public'));

   - Explanation:
     - `app.use` → built-in middleware to serve static assets
     - Path points to folder with HTML, JS, CSS
     - Browser can now load index.html and JS app
     - Enables testing of POST requests without configuring browser manually

4) Testing POST Requests:
   - Option 1: HTML Form in methods.public
     - Traditional method
     - User submits form → sends POST request to server
   - Option 2: JavaScript fetch/AJAX
     - Modern approach
     - Sends POST request programmatically
   - Alternative: Use **Postman** or **Insomnia**
     - Allows direct testing of server endpoints
     - Helpful before frontend is ready

5) Next Steps:
   - Install additional tools for faster testing:
     - Postman (npm not required, standalone app)
   - Once static folder is ready:
     - Navigate to homepage (`localhost:5000` or relevant port)
     - HTML app should load without errors
     - Forms and JS can now send POST requests to server
-----------------------------------------------------------------

TOPIC: Handling POST Requests from HTML Forms

1) HTML Form Setup (index.html):
   - Typical form with two attributes:
     1) method="POST" → indicates POST request
     2) action="/login" → path on the server to send data
   - Input field:
     - name="name"
     - id="name"
     - autocomplete attribute
   - Submit button triggers POST request

2) Observing Form POST Requests:
   - When submitting form (e.g., name=John):
     - Browser sends POST request to /login
     - HTTP method is POST (not GET)
     - Body contains key-value pair:
       - key: name
       - value: John
   - GET requests don’t have body; POST requests include body

3) Creating Server Route for POST (/login):
   // app.js
   app.post('/login', (req, res) => {
       res.send('POST');
   });
   - Initially:
     - Server responds with 'POST'
     - Cannot access submitted data yet (req.body is undefined)

4) Middleware for Parsing Form Data:
   - Express built-in middleware: URL-encoded parser
   - Adds submitted form data to req.body
   // app.js
   app.use(express.urlencoded({ extended: false }));

   - extended: false → parse URL-encoded data using querystring library
   - extended: true → uses qs library (optional, more advanced)
   - Now req.body contains key-value pairs from form submission

5) Handling Submitted Data:
   // app.js
   app.post('/login', (req, res) => {
       const { name } = req.body;

       if (name) {
           // Success response
           return res.status(200).send(`Welcome ${name}`);
       } else {
           // Empty input
           return res.status(401).send('Please provide credentials');
       }
   });

   - Example workflow:
     1) User submits "Anna" → response: Welcome Anna (200)
     2) User submits empty → response: Please provide credentials (401)

6) Key Points:
   - Form submission uses action to define path on server
   - POST method includes body; GET does not
   - req.body is undefined without URL-encoded middleware
   - Middleware is applied globally via app.use()
   - This example demonstrates basic server-side validation
   - Works if frontend and server are on the same host:
     - action="/login" refers to same server
   - For separate frontend, provide full URL for action

7) Next Steps:
   - First flavor of POST request handled (HTML form)
   - Second flavor: POST via JavaScript (fetch/AJAX)
   - Will demonstrate how to manipulate server-side data arrays
-------------------------------------------------------------

TOPIC: Handling POST Requests from JavaScript using Axios

1) Background:
   - Browser form POST (application/x-www-form-urlencoded) differs from JavaScript POST (application/json)
   - JavaScript approach allows sending HTTP requests programmatically
   - Front-end JavaScript can dynamically update the page without full reload

2) Front-End Setup:
   - index.html:
       - No action or method attributes on form
       - Input field: name="name"
       - Div/element to display results (alert/result)
   - Include Axios via CDN for easier HTTP requests
       <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   - Example of fetching people from server:
       function fetchPeople() {
           axios.get('/api/people')
               .then(res => {
                   // iterate res.data.data array
                   // display people on page
               })
               .catch(err => console.log("Can't fetch data"));
       }
       fetchPeople();

3) Sending POST Request via JavaScript (Axios):
   - Capture form submit event
   - Extract input value
   - Send POST request to server:
       const name = input.value;
       axios.post('/api/people', { name })
           .then(res => {
               // res.data contains server response
               // dynamically add new person to front-end list
           })
           .catch(err => {
               // handle errors
               // e.g., if name empty, show error message
           });

4) Server-Side Setup:
   - Separate route for POST (even if URL same as GET)
       app.post('/api/people', (req, res) => { ... });
   - Middleware required:
       1) Parse URL-encoded data (for forms):
           app.use(express.urlencoded({ extended: false }));
       2) Parse JSON data (for JavaScript/Axios):
           app.use(express.json());

5) Handling Data on Server:
   // app.js
   app.post('/api/people', (req, res) => {
       const { name } = req.body;

       if (!name) {
           // Missing name, send 400 error
           return res.status(400).json({
               success: false,
               message: 'Please provide name value'
           });
       }

       // Success, send new person back
       res.status(201).json({
           success: true,
           person: name
       });
   });

6) Key Notes:
   - POST method differs from GET even if URL is same
       - GET: reading data
       - POST: adding data
   - req.body populated only with appropriate middleware
       - express.urlencoded() for form submissions
       - express.json() for JSON payloads
   - Axios automatically sets Content-Type to application/json
   - Response structure should match front-end expectations:
       - success: boolean
       - data/person/message properties
   - Status codes:
       - 201 → successfully created
       - 400 → bad request (e.g., missing value)

7) Front-End Handling of Response:
   - On success:
       - Access data via res.data.person
       - Dynamically add to HTML list
   - On error:
       - Access error.response.data.message
       - Display error alert
   - Helps keep UI in sync with server-side changes

8) Summary:
   - Two flavors of POST requests:
       1) HTML Form (URL-encoded)
       2) JavaScript (JSON/Axios)
   - Middleware ensures req.body populated correctly
   - Response JSON used to update front-end dynamically
   - Enables future manipulation with PUT/DELETE/POST methods
------------------------------------------------------------------

PUT Method in Express - Updating Data (Full Flow with Postman Testing)

1. Purpose of PUT:
   - PUT method is used to **edit/update existing data**.
   - Conventionally, if we have a list (e.g., /api/orders or /api/people):
     - To edit/delete a specific item, we use a **route parameter**: /api/people/:id
     - This :id allows us to target a single item in the list.

2. Route Setup in Express:
   - Use `app.put()` to define a PUT route.
   - Example route for people array:
     ```
     app.put('/api/people/:id', (req, res) => {
        // Logic will go here
     });
     ```
   - Notes:
     - You can technically name the route parameter anything, e.g., :personId, but we'll use :id.
     - Convention exists to clearly indicate which resource is being updated.

3. Accessing Parameters and Body:
   - **Route params** provide the ID of the item:
     ```
     const { id } = req.params;
     ```
   - **Request body** provides the new value(s) to update:
     ```
     const { name } = req.body;
     ```
   - Both are required for updating:
     - Params → which item to update.
     - Body → what data to update it with.

4. Testing Connectivity in Postman (Initial Test):
   - URL: `/api/people/1` (change ID as needed, e.g., 1 to 5)
   - Method: PUT
   - Body: JSON (raw)
     ```
     {
       "name": "Peter"
     }
     ```
   - Temporary response for testing:
     ```
     res.send("hello world");
     ```
   - Console log (optional) to verify values:
     ```
     console.log(id, name);
     ```
   - Result:
     - Status: 200
     - Console shows ID and new name from Postman.

5. PUT Logic Implementation:
   - Find person by ID in local array:
     ```
     const person = people.find(p => p.id === Number(id));
     ```
   - If person not found → send 404 error:
     ```
     if (!person) {
         return res.status(404).json({
             success: false,
             message: `no person with id ${id}`
         });
     }
     ```
   - If person exists → update name:
     ```
     const newPeople = people.map(p => {
         if (p.id === Number(id)) {
             p.name = name; // Update name from body
         }
         return p;
     });
     ```
   - Send updated array as response:
     ```
     res.status(200).json({
         success: true,
         data: newPeople
     });
     ```

6. Full PUT Route Example:

app.put('/api/people/:id', (req, res) => {
const { id } = req.params;
const { name } = req.body;

   const person = people.find(p => p.id === Number(id));

   if (!person) {
       return res.status(404).json({
           success: false,
           message: `no person with id ${id}`
       });
   }

   const newPeople = people.map(p => {
       if (p.id === Number(id)) {
           p.name = name;
       }
       return p;
   });

   res.status(200).json({
       success: true,
       data: newPeople
   });


});


7. Testing in Postman (Final Verification):
- Path: `/api/people/1`
- PUT JSON body:
  ```
  {
    "name": "Peter"
  }
  ```
- Expected Response:
  ```
  {
    "success": true,
    "data": [
        { "id": 1, "name": "Peter" },
        { "id": 2, "name": "Alice" },
        ...
    ]
  }
  ```
- Notes:
  - If ID does not exist → returns 404 with error message.
  - If ID exists → name is updated and entire array returned.
  - You can test multiple IDs (1 to 5) and observe changes.

8. Key Points to Remember:
- PUT targets **specific resource** using route param `:id`.
- Body contains new data for the resource.
- Two key sources in request:
  - `req.params` → ID
  - `req.body` → Updated values
- Testing in Postman allows you to verify route and logic before integrating with a database.
- Local array simulates database; logic remains the same when connecting real DB later.
----------------------------------------------------------------------------------------------



DELETE Method in Express - Removing Data (Full Flow with Postman Testing)

1. Purpose of DELETE:
   - DELETE method removes an existing resource from a list.
   - Example: DELETE /api/people/1 → removes person with id=1.
   - Unlike PUT, DELETE does not expect data in the body.
   - You just hit the URL with the ID and that resource is removed.

2. Important Note on Routes:
   - Even if the path is the same (e.g., /api/people), different HTTP methods
     (GET, POST, PUT, DELETE) are considered different requests.
   - Example:
       app.get('/api/people')
       app.post('/api/people')
       app.put('/api/people/:id')
       app.delete('/api/people/:id')
   - These are all different routes, even with the same path.

3. Express DELETE Route Setup:
   app.delete('/api/people/:id', (req, res) => {
       // Logic will go here
   });

   - req.params.id → gives us the ID from the URL.
   - No req.body needed (we are just deleting).

4. Finding and Validating Person:
   const person = people.find(p => p.id === Number(req.params.id));
   if (!person) {
       return res.status(404).json({
           success: false,
           message: `no person with id ${req.params.id}`
       });
   }

   - If person not found → return 404 error with message.
   - If found → proceed to remove.

5. Deleting from Array:
   const newPeople = people.filter(p => p.id !== Number(req.params.id));

   - This excludes the person whose ID matched req.params.id.

6. Sending Response:
   res.status(200).json({
       success: true,
       data: newPeople
   });

7. Full DELETE Route Example:
   app.delete('/api/people/:id', (req, res) => {
       const person = people.find(p => p.id === Number(req.params.id));

       if (!person) {
           return res.status(404).json({
               success: false,
               message: `no person with id ${req.params.id}`
           });
       }

       const newPeople = people.filter(p => p.id !== Number(req.params.id));

       return res.status(200).json({
           success: true,
           data: newPeople
       });
   });

8. Testing in Postman:
   - Path: DELETE /api/people/abc
       Response:
       {
         "success": false,
         "message": "no person with id abc"
       }

   - Path: DELETE /api/people/1
       Response:
       {
         "success": true,
         "data": [ ... remaining people ... ]
       }

   - Body in Postman is ignored (not needed).

9. Key Notes from Instructor:
   - DELETE and PUT are very similar:
       PUT → update data
       DELETE → remove data
   - Both rely on params (:id) for identifying item.
   - Postman is used during development since it’s faster than building
     a frontend for every route.
   - In real-world apps:
       → The frontend (React, Angular, etc.) or another service will use this API.
   - Purpose of API:
       → Provide data for others to use, not just for Postman testing.


